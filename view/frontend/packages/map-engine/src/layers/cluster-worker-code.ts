// Auto-generated â€” run `bun run scripts/bundle-cluster-worker.ts` to rebuild
export const CLUSTER_WORKER_CODE =
  '(()=>{var g=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class o{static from(n){if(!(n instanceof ArrayBuffer))throw Error("Data must be an instance of ArrayBuffer.");let[f,l]=new Uint8Array(n,0,2);if(f!==219)throw Error("Data does not appear to be in a KDBush format.");let u=l>>4;if(u!==1)throw Error(`Got v${u} data when expected v1.`);let b=g[l&15];if(!b)throw Error("Unrecognized array type.");let[W]=new Uint16Array(n,2,1),[G]=new Uint32Array(n,4,1);return new o(G,W,b,n)}constructor(n,f=64,l=Float64Array,u){if(isNaN(n)||n<0)throw Error(`Unpexpected numItems value: ${n}.`);this.numItems=+n,this.nodeSize=Math.min(Math.max(+f,2),65535),this.ArrayType=l,this.IndexArrayType=n<65536?Uint16Array:Uint32Array;let b=g.indexOf(this.ArrayType),W=n*2*this.ArrayType.BYTES_PER_ELEMENT,G=n*this.IndexArrayType.BYTES_PER_ELEMENT,C=(8-G%8)%8;if(b<0)throw Error(`Unexpected typed array class: ${l}.`);if(u&&u instanceof ArrayBuffer)this.data=u,this.ids=new this.IndexArrayType(this.data,8,n),this.coords=new this.ArrayType(this.data,8+G+C,n*2),this._pos=n*2,this._finished=!0;else this.data=new ArrayBuffer(8+W+G+C),this.ids=new this.IndexArrayType(this.data,8,n),this.coords=new this.ArrayType(this.data,8+G+C,n*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+b]),new Uint16Array(this.data,2,1)[0]=f,new Uint32Array(this.data,4,1)[0]=n}add(n,f){let l=this._pos>>1;return this.ids[l]=l,this.coords[this._pos++]=n,this.coords[this._pos++]=f,l}finish(){let n=this._pos>>1;if(n!==this.numItems)throw Error(`Added ${n} items when expected ${this.numItems}.`);return Y(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(n,f,l,u){if(!this._finished)throw Error("Data not yet indexed - call index.finish().");let{ids:b,coords:W,nodeSize:G}=this,C=[0,b.length-1,0],A=[];while(C.length){let w=C.pop()||0,M=C.pop()||0,e=C.pop()||0;if(M-e<=G){for(let $=e;$<=M;$++){let y=W[2*$],K=W[2*$+1];if(y>=n&&y<=l&&K>=f&&K<=u)A.push(b[$])}continue}let R=e+M>>1,Q=W[2*R],V=W[2*R+1];if(Q>=n&&Q<=l&&V>=f&&V<=u)A.push(b[R]);if(w===0?n<=Q:f<=V)C.push(e),C.push(R-1),C.push(1-w);if(w===0?l>=Q:u>=V)C.push(R+1),C.push(M),C.push(1-w)}return A}within(n,f,l){if(!this._finished)throw Error("Data not yet indexed - call index.finish().");let{ids:u,coords:b,nodeSize:W}=this,G=[0,u.length-1,0],C=[],A=l*l;while(G.length){let w=G.pop()||0,M=G.pop()||0,e=G.pop()||0;if(M-e<=W){for(let $=e;$<=M;$++)if(s(b[2*$],b[2*$+1],n,f)<=A)C.push(u[$]);continue}let R=e+M>>1,Q=b[2*R],V=b[2*R+1];if(s(Q,V,n,f)<=A)C.push(u[R]);if(w===0?n-l<=Q:f-l<=V)G.push(e),G.push(R-1),G.push(1-w);if(w===0?n+l>=Q:f+l>=V)G.push(R+1),G.push(M),G.push(1-w)}return C}}function Y(n,f,l,u,b,W){if(b-u<=l)return;let G=u+b>>1;p(n,f,G,u,b,W),Y(n,f,l,u,G-1,1-W),Y(n,f,l,G+1,b,1-W)}function p(n,f,l,u,b,W){while(b>u){if(b-u>600){let w=b-u+1,M=l-u+1,e=Math.log(w),R=0.5*Math.exp(2*e/3),Q=0.5*Math.sqrt(e*R*(w-R)/w)*(M-w/2<0?-1:1),V=Math.max(u,Math.floor(l-M*R/w+Q)),$=Math.min(b,Math.floor(l+(w-M)*R/w+Q));p(n,f,l,V,$,W)}let G=f[2*l+W],C=u,A=b;if(Z(n,f,u,l),f[2*b+W]>G)Z(n,f,u,b);while(C<A){Z(n,f,C,A),C++,A--;while(f[2*C+W]<G)C++;while(f[2*A+W]>G)A--}if(f[2*u+W]===G)Z(n,f,u,A);else A++,Z(n,f,A,b);if(A<=l)u=A+1;if(l<=A)b=A-1}}function Z(n,f,l,u){q(n,l,u),q(f,2*l,2*u),q(f,2*l+1,2*u+1)}function q(n,f,l){let u=n[f];n[f]=n[l],n[l]=u}function s(n,f,l,u){let b=n-l,W=f-u;return b*b+W*W}var d={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:(n)=>n},i=Math.fround||((n)=>(f)=>{return n[0]=+f,n[0]})(new Float32Array(1)),J=2,B=3,F=4,v=5,z=6;class L{constructor(n){this.options=Object.assign(Object.create(d),n),this.trees=Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(n){let{log:f,minZoom:l,maxZoom:u}=this.options;if(f)console.time("total time");let b=`prepare ${n.length} points`;if(f)console.time(b);this.points=n;let W=[];for(let C=0;C<n.length;C++){let A=n[C];if(!A.geometry)continue;let[w,M]=A.geometry.coordinates,e=i(c(w)),R=i(E(M));if(W.push(e,R,1/0,C,-1,1),this.options.reduce)W.push(0)}let G=this.trees[u+1]=this._createTree(W);if(f)console.timeEnd(b);for(let C=u;C>=l;C--){let A=+Date.now();if(G=this.trees[C]=this._createTree(this._cluster(G,C)),f)console.log("z%d: %d clusters in %dms",C,G.numItems,+Date.now()-A)}if(f)console.timeEnd("total time");return this}getClusters(n,f){let l=((n[0]+180)%360+360)%360-180,u=Math.max(-90,Math.min(90,n[1])),b=n[2]===180?180:((n[2]+180)%360+360)%360-180,W=Math.max(-90,Math.min(90,n[3]));if(n[2]-n[0]>=360)l=-180,b=180;else if(l>b){let M=this.getClusters([l,u,180,W],f),e=this.getClusters([-180,u,b,W],f);return M.concat(e)}let G=this.trees[this._limitZoom(f)],C=G.range(c(l),E(W),c(b),E(u)),A=G.data,w=[];for(let M of C){let e=this.stride*M;w.push(A[e+v]>1?r(A,e,this.clusterProps):this.points[A[e+B]])}return w}getChildren(n){let f=this._getOriginId(n),l=this._getOriginZoom(n),u="No cluster with the specified id.",b=this.trees[l];if(!b)throw Error("No cluster with the specified id.");let W=b.data;if(f*this.stride>=W.length)throw Error("No cluster with the specified id.");let G=this.options.radius/(this.options.extent*Math.pow(2,l-1)),C=W[f*this.stride],A=W[f*this.stride+1],w=b.within(C,A,G),M=[];for(let e of w){let R=e*this.stride;if(W[R+F]===n)M.push(W[R+v]>1?r(W,R,this.clusterProps):this.points[W[R+B]])}if(M.length===0)throw Error("No cluster with the specified id.");return M}getLeaves(n,f,l){f=f||10,l=l||0;let u=[];return this._appendLeaves(u,n,f,l,0),u}getTile(n,f,l){let u=this.trees[this._limitZoom(n)],b=Math.pow(2,n),{extent:W,radius:G}=this.options,C=G/W,A=(l-C)/b,w=(l+1+C)/b,M={features:[]};if(this._addTileFeatures(u.range((f-C)/b,A,(f+1+C)/b,w),u.data,f,l,b,M),f===0)this._addTileFeatures(u.range(1-C/b,A,1,w),u.data,b,l,b,M);if(f===b-1)this._addTileFeatures(u.range(0,A,C/b,w),u.data,-1,l,b,M);return M.features.length?M:null}getClusterExpansionZoom(n){let f=this._getOriginZoom(n)-1;while(f<=this.options.maxZoom){let l=this.getChildren(n);if(f++,l.length!==1)break;n=l[0].properties.cluster_id}return f}_appendLeaves(n,f,l,u,b){let W=this.getChildren(f);for(let G of W){let C=G.properties;if(C&&C.cluster)if(b+C.point_count<=u)b+=C.point_count;else b=this._appendLeaves(n,C.cluster_id,l,u,b);else if(b<u)b++;else n.push(G);if(n.length===l)break}return b}_createTree(n){let f=new o(n.length/this.stride|0,this.options.nodeSize,Float32Array);for(let l=0;l<n.length;l+=this.stride)f.add(n[l],n[l+1]);return f.finish(),f.data=n,f}_addTileFeatures(n,f,l,u,b,W){for(let G of n){let C=G*this.stride,A=f[C+v]>1,w,M,e;if(A)w=k(f,C,this.clusterProps),M=f[C],e=f[C+1];else{let V=this.points[f[C+B]];w=V.properties;let[$,y]=V.geometry.coordinates;M=c($),e=E(y)}let R={type:1,geometry:[[Math.round(this.options.extent*(M*b-l)),Math.round(this.options.extent*(e*b-u))]],tags:w},Q;if(A||this.options.generateId)Q=f[C+B];else Q=this.points[f[C+B]].id;if(Q!==void 0)R.id=Q;W.features.push(R)}}_limitZoom(n){return Math.max(this.options.minZoom,Math.min(Math.floor(+n),this.options.maxZoom+1))}_cluster(n,f){let{radius:l,extent:u,reduce:b,minPoints:W}=this.options,G=l/(u*Math.pow(2,f)),C=n.data,A=[],w=this.stride;for(let M=0;M<C.length;M+=w){if(C[M+J]<=f)continue;C[M+J]=f;let e=C[M],R=C[M+1],Q=n.within(C[M],C[M+1],G),V=C[M+v],$=V;for(let y of Q){let K=y*w;if(C[K+J]>f)$+=C[K+v]}if($>V&&$>=W){let y=e*V,K=R*V,U,_=-1,N=((M/w|0)<<5)+(f+1)+this.points.length;for(let X of Q){let H=X*w;if(C[H+J]<=f)continue;C[H+J]=f;let I=C[H+v];if(y+=C[H]*I,K+=C[H+1]*I,C[H+F]=N,b){if(!U)U=this._map(C,M,!0),_=this.clusterProps.length,this.clusterProps.push(U);b(U,this._map(C,H))}}if(C[M+F]=N,A.push(y/$,K/$,1/0,N,-1,$),b)A.push(_)}else{for(let y=0;y<w;y++)A.push(C[M+y]);if($>1)for(let y of Q){let K=y*w;if(C[K+J]<=f)continue;C[K+J]=f;for(let U=0;U<w;U++)A.push(C[K+U])}}}return A}_getOriginId(n){return n-this.points.length>>5}_getOriginZoom(n){return(n-this.points.length)%32}_map(n,f,l){if(n[f+v]>1){let W=this.clusterProps[n[f+z]];return l?Object.assign({},W):W}let u=this.points[n[f+B]].properties,b=this.options.map(u);return l&&b===u?Object.assign({},b):b}}function r(n,f,l){return{type:"Feature",id:n[f+B],properties:k(n,f,l),geometry:{type:"Point",coordinates:[nn(n[f]),fn(n[f+1])]}}}function k(n,f,l){let u=n[f+v],b=u>=1e4?`${Math.round(u/1000)}k`:u>=1000?`${Math.round(u/100)/10}k`:u,W=n[f+z],G=W===-1?{}:Object.assign({},l[W]);return Object.assign(G,{cluster:!0,cluster_id:n[f+B],point_count:u,point_count_abbreviated:b})}function c(n){return n/360+0.5}function E(n){let f=Math.sin(n*Math.PI/180),l=0.5-0.25*Math.log((1+f)/(1-f))/Math.PI;return l<0?0:l>1?1:l}function nn(n){return(n-0.5)*360}function fn(n){let f=(180-n*360)*Math.PI/180;return 360*Math.atan(Math.exp(f))/Math.PI-90}var j=100,ln=15,m=13,x=10,S=128;var un=["blue","red","neutral","unknown"];function t(n){if(n>=m)return"symbol";if(n>=x)return"affiliation";return"all"}function T(n){return un[n]}function O(n,f,l){let u=n.positions[f*2+1],b=n.positions[f*2];return{type:"Feature",geometry:{type:"Point",coordinates:[u,b]},properties:{cluster:!1,entityId:n.ids[f],affiliation:l,symbol:n.symbols[f]??void 0}}}function a(){let n=null,f=new Map,l=new Map,u=null;function b(A,w,M){let{count:e}=A;if(M==="symbol"){let R=new Map;for(let Q=0;Q<e;Q++){let V=T(A.affiliations[Q]);if(!w[V])continue;let $=A.symbols[Q];if(!$)continue;let y=R.get($)??[];y.push(O(A,Q,V)),R.set($,y)}l=new Map;for(let[Q,V]of R){let $=new L({radius:j,maxZoom:ln,minPoints:3,nodeSize:S,map:(y)=>({symbol:y.symbol}),reduce:(y,K)=>{y.symbol=K.symbol}});$.load(V),l.set(Q,$)}}else if(M==="affiliation"){let R=new Map;for(let Q=0;Q<e;Q++){let V=T(A.affiliations[Q]);if(!w[V])continue;if(!A.symbols[Q])continue;let $=R.get(V)??[];$.push(O(A,Q,V)),R.set(V,$)}f=new Map;for(let[Q,V]of R){let $=new L({radius:j,maxZoom:m-1,minPoints:3,nodeSize:S,map:(y)=>({affiliation:y.affiliation}),reduce:(y,K)=>{y.affiliation=K.affiliation}});$.load(V),f.set(Q,$)}}else{let R=[];for(let Q=0;Q<e;Q++){let V=T(A.affiliations[Q]);if(!w[V])continue;if(!A.symbols[Q])continue;R.push(O(A,Q,V))}n=new L({radius:j,maxZoom:x-1,minPoints:3,nodeSize:S}),n.load(R)}u=M}function W(A){let w=Math.floor(A),M=[-180,-85,180,85],e=t(w),R=[];if(e==="symbol")for(let[V,$]of l.entries())for(let y of $.getClusters(M,w))y._sourceSymbol=V,R.push(y);else if(e==="affiliation")R=[...f.values()].flatMap((V)=>V.getClusters(M,w));else if(n)R=n.getClusters(M,w);let Q=[];for(let V of R){let $=V.geometry.coordinates,[y,K]=$,U=V.properties,_=V._sourceSymbol;if(U.cluster){let N=_??U.symbol,X=e==="symbol"?N??"unknown":e==="affiliation"?U.affiliation??"unknown":"all";Q.push({isCluster:!0,lat:K,lng:y,clusterId:U.cluster_id,count:U.point_count??0,clusterKey:X,affiliation:U.affiliation??"unknown",symbol:e==="symbol"?N:void 0})}else Q.push({isCluster:!1,lat:K,lng:y,entityId:U.entityId,affiliation:U.affiliation??"unknown",symbol:U.symbol})}return Q}let G=null;function C(A,w,M,e){let R=t(Math.floor(M)),Q=R!==u,V=!G||w.blue!==G.blue||w.red!==G.red||w.neutral!==G.neutral||w.unknown!==G.unknown;if(e||Q||V||u===null)b(A,w,R),G={...w};return W(M)}return{process:C}}var h=a(),P=null,D=null;addEventListener("message",(n)=>{let{zoom:f,version:l}=n.data;if("positions"in n.data){let{positions:u,affiliations:b,ids:W,symbols:G,count:C,filter:A,geoChanged:w}=n.data;P={positions:u,affiliations:b,ids:W,symbols:G,count:C},D=A;let M=h.process(P,A,f,w);postMessage({clusters:M,version:l})}else if("filter"in n.data&&P){let u=n.data.filter;D=u;let b=h.process(P,u,f,!1);postMessage({clusters:b,version:l})}else if(P&&D){let u=h.process(P,D,f,!1);postMessage({clusters:u,version:l})}});})();\n';
